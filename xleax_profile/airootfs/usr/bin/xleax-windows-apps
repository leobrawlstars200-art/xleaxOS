#!/usr/bin/env bash
set -euo pipefail

CONFIG_FILE="/etc/xleax/windows-apps.conf"
STATE_FILE="/run/xleax/windows-apps.state"
VM_NAME="windowsapps"
VFIO_PCI_DEVICES=""
AUTO_STOP_DISPLAY_MANAGER=true
DISPLAY_MANAGER_SERVICE="gdm.service"

if [ -r "$CONFIG_FILE" ]; then
  # shellcheck disable=SC1090
  source "$CONFIG_FILE"
fi

if [ "$(id -u)" -ne 0 ]; then
  echo "xleax-windows-apps: run as root (use pkexec)." >&2
  exit 1
fi

usage() {
  cat <<'EOF'
Usage: xleax-windows-apps [start|stop|status] [vm-name]
EOF
}

action="${1:-start}"
case "$action" in
  start|stop|status) ;;
  *)
    usage
    exit 64
    ;;
esac

if [ -n "${2:-}" ]; then
  VM_NAME="$2"
fi

pick_default_gpu() {
  local dev class boot_vga

  for dev in /sys/bus/pci/devices/*; do
    [ -e "$dev/class" ] || continue
    class="$(cat "$dev/class" 2>/dev/null || true)"
    case "$class" in
      0x030000|0x030200)
        boot_vga="$(cat "$dev/boot_vga" 2>/dev/null || echo 0)"
        if [ "$boot_vga" != "1" ]; then
          basename "$dev"
          return 0
        fi
        ;;
    esac
  done

  for dev in /sys/bus/pci/devices/*; do
    [ -e "$dev/class" ] || continue
    class="$(cat "$dev/class" 2>/dev/null || true)"
    case "$class" in
      0x030000|0x030200)
        basename "$dev"
        return 0
        ;;
    esac
  done

  return 1
}

get_device_list() {
  local audio selected

  if [ -n "${VFIO_PCI_DEVICES// }" ]; then
    printf '%s\n' "$VFIO_PCI_DEVICES" | tr ', ' '\n\n' | awk 'NF' | sort -u
    return
  fi

  selected="$(pick_default_gpu 2>/dev/null || true)"
  [ -n "$selected" ] || return 0

  printf '%s\n' "$selected"
  audio="${selected%.*}.1"
  if [ -e "/sys/bus/pci/devices/$audio/class" ] && grep -qi '^0x0403' "/sys/bus/pci/devices/$audio/class"; then
    printf '%s\n' "$audio"
  fi
}

bind_to_vfio() {
  local bdf="$1" dev="/sys/bus/pci/devices/$bdf" driver
  [ -d "$dev" ] || return 0

  if [ -L "$dev/driver" ]; then
    driver="$(basename "$(readlink -f "$dev/driver")")"
    echo "$bdf" > "/sys/bus/pci/drivers/$driver/unbind" 2>/dev/null || true
  fi

  if ! echo vfio-pci > "$dev/driver_override"; then
    return 1
  fi
  if ! echo "$bdf" > /sys/bus/pci/drivers/vfio-pci/bind 2>/dev/null; then
    return 1
  fi

  return 0
}

rebind_from_vfio() {
  local bdf="$1" dev="/sys/bus/pci/devices/$bdf"
  [ -d "$dev" ] || return 0

  if [ -L "$dev/driver" ] && [ "$(basename "$(readlink -f "$dev/driver")")" = "vfio-pci" ]; then
    echo "$bdf" > /sys/bus/pci/drivers/vfio-pci/unbind 2>/dev/null || true
  fi

  : > "$dev/driver_override"
  echo "$bdf" > /sys/bus/pci/drivers_probe 2>/dev/null || true
}

disable_local_display() {
  if [ "$AUTO_STOP_DISPLAY_MANAGER" = true ]; then
    systemctl stop "$DISPLAY_MANAGER_SERVICE" 2>/dev/null || true
  fi
  for vt in /sys/class/vtconsole/vtcon*/bind; do
    echo 0 > "$vt" 2>/dev/null || true
  done
  if [ -e /sys/bus/platform/drivers/efi-framebuffer/unbind ]; then
    echo efi-framebuffer.0 > /sys/bus/platform/drivers/efi-framebuffer/unbind 2>/dev/null || true
  fi
}

restore_local_display() {
  if [ -e /sys/bus/platform/drivers/efi-framebuffer/bind ]; then
    echo efi-framebuffer.0 > /sys/bus/platform/drivers/efi-framebuffer/bind 2>/dev/null || true
  fi
  for vt in /sys/class/vtconsole/vtcon*/bind; do
    echo 1 > "$vt" 2>/dev/null || true
  done
  if [ "$AUTO_STOP_DISPLAY_MANAGER" = true ]; then
    systemctl start "$DISPLAY_MANAGER_SERVICE" 2>/dev/null || true
  fi
}

rollback_start() {
  local display_disabled="${1:-0}"
  shift || true
  local bdf

  for bdf in "$@"; do
    [ -n "$bdf" ] || continue
    rebind_from_vfio "$bdf"
  done

  if [ "$display_disabled" -eq 1 ]; then
    restore_local_display
  fi
}

start_vm() {
  local -a devices=()
  local -a bound_devices=()
  local bdf
  local display_disabled=0

  if ! command -v virsh >/dev/null 2>&1; then
    echo "xleax-windows-apps: virsh is not installed." >&2
    exit 3
  fi
  if ! virsh dominfo "$VM_NAME" >/dev/null 2>&1; then
    echo "xleax-windows-apps: VM '$VM_NAME' does not exist." >&2
    exit 3
  fi

  mapfile -t devices < <(get_device_list)
  if [ "${#devices[@]}" -eq 0 ]; then
    echo "xleax-windows-apps: no passthrough GPU devices detected." >&2
    exit 2
  fi

  modprobe vfio
  modprobe vfio_iommu_type1
  modprobe vfio-pci

  disable_local_display
  display_disabled=1

  for bdf in "${devices[@]}"; do
    if bind_to_vfio "$bdf"; then
      bound_devices+=("$bdf")
    else
      rollback_start "$display_disabled" "${bound_devices[@]}"
      echo "xleax-windows-apps: failed to bind $bdf to vfio-pci." >&2
      exit 4
    fi
  done

  if ! virsh start "$VM_NAME"; then
    rollback_start "$display_disabled" "${bound_devices[@]}"
    echo "xleax-windows-apps: failed to start VM '$VM_NAME'." >&2
    exit 5
  fi

  mkdir -p "$(dirname "$STATE_FILE")"
  : > "$STATE_FILE"
  printf 'VM_NAME=%s\n' "$VM_NAME" >> "$STATE_FILE"
  printf 'DEVICES=%s\n' "${devices[*]}" >> "$STATE_FILE"

  echo "xleax-windows-apps: VM $VM_NAME started with VFIO GPU passthrough."
}

stop_vm() {
  local state_vm="$VM_NAME" state_devices="" bdf

  if [ -r "$STATE_FILE" ]; then
    # shellcheck disable=SC1090
    source "$STATE_FILE"
    state_vm="${VM_NAME:-$state_vm}"
    state_devices="${DEVICES:-}"
  fi

  if virsh domstate "$state_vm" 2>/dev/null | grep -qi running; then
    virsh shutdown "$state_vm" || true
    for _ in $(seq 1 30); do
      if ! virsh domstate "$state_vm" 2>/dev/null | grep -qi running; then
        break
      fi
      sleep 2
    done
    if virsh domstate "$state_vm" 2>/dev/null | grep -qi running; then
      virsh destroy "$state_vm" || true
    fi
  fi

  if [ -n "$state_devices" ]; then
    for bdf in $state_devices; do
      rebind_from_vfio "$bdf"
    done
  else
    while IFS= read -r bdf; do
      rebind_from_vfio "$bdf"
    done < <(get_device_list)
  fi

  restore_local_display
  rm -f "$STATE_FILE"
  echo "xleax-windows-apps: VM stopped and devices rebound to host."
}

print_status() {
  echo "VM: $VM_NAME"
  virsh domstate "$VM_NAME" 2>/dev/null || echo "domstate: unavailable"

  echo "GPU passthrough devices:"
  while IFS= read -r bdf; do
    [ -z "$bdf" ] && continue
    if [ -L "/sys/bus/pci/devices/$bdf/driver" ]; then
      printf '  %s -> %s\n' "$bdf" "$(basename "$(readlink -f "/sys/bus/pci/devices/$bdf/driver")")"
    else
      printf '  %s -> (unbound)\n' "$bdf"
    fi
  done < <(get_device_list)
}

case "$action" in
  start)
    start_vm
    ;;
  stop)
    stop_vm
    ;;
  status)
    print_status
    ;;
esac
